{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../Dropzone.svelte",
    "../QuestionAnswerStats.svelte"
  ],
  "sourcesContent": [
    "<script>\r\n  import { fromEvent } from \"file-selector\";\r\n  import {\r\n    allFilesAccepted,\r\n    composeEventHandlers,\r\n    fileAccepted,\r\n    fileMatchSize,\r\n    isEvtWithFiles,\r\n    isIeOrEdge,\r\n    isPropagationStopped,\r\n    onDocumentDragOver,\r\n    TOO_MANY_FILES_REJECTION\r\n  } from \"./../utils/index\";\r\n  import { onMount, onDestroy, createEventDispatcher } from \"svelte\";\r\n\r\n  //props\r\n  /**\r\n   * Set accepted file types.\r\n   * See https://github.com/okonet/attr-accept for more information.\r\n   */\r\n  export let accept; // string or string[]\r\n  export let disabled = false;\r\n  export let getFilesFromEvent = fromEvent;\r\n  export let maxSize = Infinity;\r\n  export let minSize = 0;\r\n  export let multiple = true;\r\n  export let preventDropOnDocument = true;\r\n  export let noClick = false;\r\n  export let noKeyboard = false;\r\n  export let noDrag = false;\r\n  export let noDragEventsBubbling = false;\r\n  export let containerClasses = \"\";\r\n  export let containerStyles = \"\";\r\n  export let disableDefaultStyles = false;\r\n\r\n  const dispatch = createEventDispatcher();\r\n\r\n  //state\r\n\r\n  let state = {\r\n    isFocused: false,\r\n    isFileDialogActive: false,\r\n    isDragActive: false,\r\n    isDragAccept: false,\r\n    isDragReject: false,\r\n    draggedFiles: [],\r\n    acceptedFiles: [],\r\n    fileRejections: []\r\n  };\r\n\r\n  let rootRef;\r\n  let inputRef;\r\n\r\n  function resetState() {\r\n    state.isFileDialogActive = false;\r\n    state.isDragActive = false;\r\n    state.draggedFiles = [];\r\n    state.acceptedFiles = [];\r\n    state.fileRejections = [];\r\n  }\r\n\r\n  // Fn for opening the file dialog programmatically\r\n  function openFileDialog() {\r\n    if (inputRef) {\r\n      inputRef.value = null; // TODO check if null needs to be set\r\n      state.isFileDialogActive = true;\r\n      inputRef.click();\r\n    }\r\n  }\r\n\r\n  // Cb to open the file dialog when SPACE/ENTER occurs on the dropzone\r\n  function onKeyDownCb(event) {\r\n    // Ignore keyboard events bubbling up the DOM tree\r\n    if (!rootRef || !rootRef.isEqualNode(event.target)) {\r\n      return;\r\n    }\r\n\r\n    if (event.keyCode === 32 || event.keyCode === 13) {\r\n      event.preventDefault();\r\n      openFileDialog();\r\n    }\r\n  }\r\n\r\n  // Update focus state for the dropzone\r\n  function onFocusCb() {\r\n    state.isFocused = true;\r\n  }\r\n  function onBlurCb() {\r\n    state.isFocused = false;\r\n  }\r\n\r\n  // Cb to open the file dialog when click occurs on the dropzone\r\n  function onClickCb() {\r\n    if (noClick) {\r\n      return;\r\n    }\r\n\r\n    // In IE11/Edge the file-browser dialog is blocking, therefore, use setTimeout()\r\n    // to ensure React can handle state changes\r\n    // See: https://github.com/react-dropzone/react-dropzone/issues/450\r\n    if (isIeOrEdge()) {\r\n      setTimeout(openFileDialog, 0);\r\n    } else {\r\n      openFileDialog();\r\n    }\r\n  }\r\n\r\n  function onDragEnterCb(event) {\r\n    event.preventDefault();\r\n    stopPropagation(event);\r\n\r\n    dragTargetsRef = [...dragTargetsRef, event.target];\r\n\r\n    if (isEvtWithFiles(event)) {\r\n      Promise.resolve(getFilesFromEvent(event)).then(draggedFiles => {\r\n        if (isPropagationStopped(event) && !noDragEventsBubbling) {\r\n          return;\r\n        }\r\n\r\n        state.draggedFiles = draggedFiles;\r\n        state.isDragActive = true;\r\n\r\n        dispatch(\"dragenter\", {\r\n          dragEvent: event\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  function onDragOverCb(event) {\r\n    event.preventDefault();\r\n    stopPropagation(event);\r\n\r\n    if (event.dataTransfer) {\r\n      try {\r\n        event.dataTransfer.dropEffect = \"copy\";\r\n      } catch {} /* eslint-disable-line no-empty */\r\n    }\r\n\r\n    if (isEvtWithFiles(event)) {\r\n      dispatch(\"dragover\", {\r\n        dragEvent: event\r\n      });\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function onDragLeaveCb(event) {\r\n    event.preventDefault();\r\n    stopPropagation(event);\r\n\r\n    // Only deactivate once the dropzone and all children have been left\r\n    const targets = dragTargetsRef.filter(\r\n      target => rootRef && rootRef.contains(target)\r\n    );\r\n    // Make sure to remove a target present multiple times only once\r\n    // (Firefox may fire dragenter/dragleave multiple times on the same element)\r\n    const targetIdx = targets.indexOf(event.target);\r\n    if (targetIdx !== -1) {\r\n      targets.splice(targetIdx, 1);\r\n    }\r\n    dragTargetsRef = targets;\r\n    if (targets.length > 0) {\r\n      return;\r\n    }\r\n\r\n    state.isDragActive = false;\r\n    state.draggedFiles = [];\r\n\r\n    if (isEvtWithFiles(event)) {\r\n      dispatch(\"dragleave\", {\r\n        dragEvent: event\r\n      });\r\n    }\r\n  }\r\n\r\n  function onDropCb(event) {\r\n    event.preventDefault();\r\n    stopPropagation(event);\r\n\r\n    dragTargetsRef = [];\r\n\r\n    if (isEvtWithFiles(event)) {\r\n      Promise.resolve(getFilesFromEvent(event)).then(files => {\r\n        if (isPropagationStopped(event) && !noDragEventsBubbling) {\r\n          return;\r\n        }\r\n\r\n        const acceptedFiles = [];\r\n        const fileRejections = [];\r\n\r\n        files.forEach(file => {\r\n          const [accepted, acceptError] = fileAccepted(file, accept);\r\n          const [sizeMatch, sizeError] = fileMatchSize(file, minSize, maxSize);\r\n          if (accepted && sizeMatch) {\r\n            acceptedFiles.push(file);\r\n          } else {\r\n            const errors = [acceptError, sizeError].filter(e => e);\r\n            fileRejections.push({ file, errors });\r\n          }\r\n        });\r\n\r\n        if (!multiple && acceptedFiles.length > 1) {\r\n          // Reject everything and empty accepted files\r\n          acceptedFiles.forEach(file => {\r\n            fileRejections.push({ file, errors: [TOO_MANY_FILES_REJECTION] });\r\n          });\r\n          acceptedFiles.splice(0);\r\n        }\r\n\r\n        state.acceptedFiles = acceptedFiles;\r\n        state.fileRejections = fileRejections;\r\n\r\n        dispatch(\"drop\", {\r\n          acceptedFiles,\r\n          fileRejections,\r\n          event\r\n        });\r\n\r\n        if (fileRejections.length > 0) {\r\n          dispatch(\"droprejected\", {\r\n            fileRejections,\r\n            event\r\n          });\r\n        }\r\n\r\n        if (acceptedFiles.length > 0) {\r\n          dispatch(\"dropaccepted\", {\r\n            acceptedFiles,\r\n            event\r\n          });\r\n        }\r\n      });\r\n    }\r\n    resetState();\r\n  }\r\n\r\n  function composeHandler(fn) {\r\n    return disabled ? null : fn;\r\n  }\r\n\r\n  function composeKeyboardHandler(fn) {\r\n    return noKeyboard ? null : composeHandler(fn);\r\n  }\r\n\r\n  function composeDragHandler(fn) {\r\n    return noDrag ? null : composeHandler(fn);\r\n  }\r\n\r\n  function stopPropagation(event) {\r\n    if (noDragEventsBubbling) {\r\n      event.stopPropagation();\r\n    }\r\n  }\r\n\r\n  let dragTargetsRef = [];\r\n  function onDocumentDrop(event) {\r\n    if (rootRef && rootRef.contains(event.target)) {\r\n      // If we intercepted an event for our instance, let it propagate down to the instance's onDrop handler\r\n      return;\r\n    }\r\n    event.preventDefault();\r\n    dragTargetsRef = [];\r\n  }\r\n\r\n  // Update file dialog active state when the window is focused on\r\n  function onWindowFocus() {\r\n    // Execute the timeout only if the file dialog is opened in the browser\r\n    if (state.isFileDialogActive) {\r\n      setTimeout(() => {\r\n        if (inputRef) {\r\n          const { files } = inputRef;\r\n\r\n          if (!files.length) {\r\n            state.isFileDialogActive = false;\r\n            dispatch(\"filedialogcancel\");\r\n          }\r\n        }\r\n      }, 300);\r\n    }\r\n  }\r\n\r\n  onMount(() => {\r\n    window.addEventListener(\"focus\", onWindowFocus, false);\r\n    if (preventDropOnDocument) {\r\n      document.addEventListener(\"dragover\", onDocumentDragOver, false);\r\n      document.addEventListener(\"drop\", onDocumentDrop, false);\r\n    }\r\n  });\r\n\r\n  onDestroy(() => {\r\n    window.removeEventListener(\"focus\", onWindowFocus, false);\r\n    if (preventDropOnDocument) {\r\n      document.removeEventListener(\"dragover\", onDocumentDragOver);\r\n      document.removeEventListener(\"drop\", onDocumentDrop);\r\n    }\r\n  });\r\n\r\n  function onInputElementClick(event) {\r\n    event.stopPropagation();\r\n  }\r\n</script>\r\n\r\n<style>\r\n  .dropzone {\r\n    flex: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    padding: 20px;\r\n    border-width: 2px;\r\n    border-radius: 2px;\r\n    border-color: #eeeeee;\r\n    border-style: dashed;\r\n    background-color: #fafafa;\r\n    color: #bdbdbd;\r\n    outline: none;\r\n    transition: border 0.24s ease-in-out;\r\n  }\r\n  .dropzone:focus {\r\n    border-color: #2196f3;\r\n  }\r\n</style>\r\n\r\n<div\r\n  bind:this={rootRef}\r\n  tabindex=\"0\"\r\n  class=\"{disableDefaultStyles ? '' : 'dropzone'}\r\n  {containerClasses}\"\r\n  style={containerStyles}\r\n  on:keydown={composeKeyboardHandler(onKeyDownCb)}\r\n  on:focus={composeKeyboardHandler(onFocusCb)}\r\n  on:blur={composeKeyboardHandler(onBlurCb)}\r\n  on:click={composeHandler(onClickCb)}\r\n  on:dragenter={composeDragHandler(onDragEnterCb)}\r\n  on:dragover={composeDragHandler(onDragOverCb)}\r\n  on:dragleave={composeDragHandler(onDragLeaveCb)}\r\n  on:drop={composeDragHandler(onDropCb)}>\r\n  <input\r\n    {accept}\r\n    {multiple}\r\n    type=\"file\"\r\n    autocomplete=\"off\"\r\n    tabindex=\"-1\"\r\n    on:change={onDropCb}\r\n    on:click={onInputElementClick}\r\n    bind:this={inputRef}\r\n    style=\"display: none;\" />\r\n  <slot>\r\n    <p>Drag 'n' drop some files here, or click to select files</p>\r\n  </slot>\r\n</div>\r\n",
    "<script>\n\texport let question;\n\texport let answersCount;\n    export let answerStats;\n    \n    $: sortedAnswerStats =[...answerStats]\n        .sort(([_, count1], [__, count2]) => count2 - count1)\n        .map(([answer, count]) => ({answer, count, items: Array(count).fill('🦊')}))\n</script>\n\n<section class=\"question-answer-stats\">\n    <h1>{question} ({answersCount} réponses)</h1>\n    <ul>\n        {#each sortedAnswerStats as {answer, count, items}}\n        <li>\n            <span class=\"answer\">{answer}</span>\n            <span class=\"count\">{count}/{answersCount}</span>\n            {#each items as i}{i}{/each}\n        </li>\n        {/each}\n    </ul>\n</section>\n\n<style>\n    .question-answer-stats{\n        margin-bottom: 1em;\n    }\n\n    .question-answer-stats h1{\n        font-size: 1.2rem;\n    }\n\n    .question-answer-stats li .count{\n        display: inline-block;\n        width: 4em;\n        font-weight: bold;\n        text-align: center;\n    }\n\n    .question-answer-stats li .answer{\n        display: block;\n    }\n    \n\n</style>\n\n"
  ],
  "names": [],
  "mappings": "AAiTE,SAAS,cAAC,CAAC,AACT,IAAI,CAAE,CAAC,CACP,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,OAAO,CAAE,IAAI,CACb,YAAY,CAAE,GAAG,CACjB,aAAa,CAAE,GAAG,CAClB,YAAY,CAAE,OAAO,CACrB,YAAY,CAAE,MAAM,CACpB,gBAAgB,CAAE,OAAO,CACzB,KAAK,CAAE,OAAO,CACd,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,MAAM,CAAC,KAAK,CAAC,WAAW,AACtC,CAAC,AACD,uBAAS,MAAM,AAAC,CAAC,AACf,YAAY,CAAE,OAAO,AACvB,CAAC;AC1SC,kDAAsB,CAAC,AACnB,aAAa,CAAE,GAAG,AACtB,CAAC,AAED,oCAAsB,CAAC,gBAAE,CAAC,AACtB,SAAS,CAAE,MAAM,AACrB,CAAC,AAED,oCAAsB,CAAC,EAAE,CAAC,oBAAM,CAAC,AAC7B,OAAO,CAAE,YAAY,CACrB,KAAK,CAAE,GAAG,CACV,WAAW,CAAE,IAAI,CACjB,UAAU,CAAE,MAAM,AACtB,CAAC,AAED,oCAAsB,CAAC,EAAE,CAAC,qBAAO,CAAC,AAC9B,OAAO,CAAE,KAAK,AAClB,CAAC"
}